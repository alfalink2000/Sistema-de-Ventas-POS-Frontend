// src/controllers/offline/InventoryOfflineController/InventoryOfflineController.js
import BaseOfflineController from "../BaseOfflineController/BaseOfflineController";
import IndexedDBService from "../../../services/IndexedDBService";

class InventoryOfflineController extends BaseOfflineController {
  constructor() {
    super();
    this.storeName = "stock_pendientes";
  }

  // ‚úÖ AGREGAR ACTUALIZACI√ìN DE STOCK PENDIENTE
  async addPendingStockUpdate(productoId, nuevoStock, productoData = {}) {
    try {
      console.log(
        `üì¶ [OFFLINE] Agregando actualizaci√≥n pendiente: ${productoId} -> ${nuevoStock}`
      );

      const productoNombre =
        productoData.producto_nombre || productoData.nombre || productoId;
      const stockAnterior =
        productoData.stock_actual || productoData.stock || 0;

      const stockUpdate = {
        id_local: `stock_${Date.now()}_${Math.random()
          .toString(36)
          .substr(2, 9)}`,
        producto_id: productoId,
        stock_anterior: stockAnterior,
        stock_nuevo: parseInt(nuevoStock),
        timestamp: new Date().toISOString(),
        sincronizado: false,
        producto_nombre: productoNombre,
        descripcion: `Stock actualizado: ${productoNombre} (${stockAnterior} ‚Üí ${nuevoStock})`,
        usuario_id: this.getCurrentUserId(),
        intentos: 0,
        ultimo_intento: null,
      };

      const success = await IndexedDBService.add(this.storeName, stockUpdate);

      if (success) {
        console.log(
          `‚úÖ [OFFLINE] Actualizaci√≥n pendiente guardada: ${stockUpdate.id_local}`
        );
        this.notifyStockPendingUpdate();
        return stockUpdate.id_local;
      } else {
        throw new Error("No se pudo guardar la actualizaci√≥n pendiente");
      }
    } catch (error) {
      console.error(
        "‚ùå [OFFLINE] Error agregando actualizaci√≥n pendiente:",
        error
      );
      throw error;
    }
  }

  async getPendingStockUpdates() {
    try {
      console.log(
        "üîç [OFFLINE] Buscando actualizaciones pendientes de stock..."
      );

      // ‚úÖ OPCI√ìN 1: Obtener TODOS los registros y filtrar manualmente (M√ÅS SEGURO)
      const allUpdates = await IndexedDBService.getAll(this.storeName);
      console.log(
        `üì¶ [OFFLINE] ${allUpdates.length} registros totales en ${this.storeName}`
      );

      // ‚úÖ FILTRAR MANUALMENTE - Evitar problemas con √≠ndices booleanos
      const pendingUpdates = allUpdates.filter((update) => {
        const isPending =
          update.sincronizado === false ||
          update.sincronizado === undefined ||
          update.sincronizado === null;
        return isPending;
      });

      console.log(
        `üì¶ [OFFLINE] ${pendingUpdates.length} actualizaciones pendientes encontradas (filtro manual)`
      );

      // ‚úÖ LOG DETALLADO PARA DEBUG
      if (pendingUpdates.length === 0 && allUpdates.length > 0) {
        console.warn(
          "‚ö†Ô∏è [OFFLINE] Hay registros pero ninguno marcado como pendiente:"
        );
        allUpdates.forEach((update) => {
          console.log(
            `   - ${update.id_local}: sincronizado = ${update.sincronizado}`
          );
        });
      }

      return pendingUpdates;
    } catch (error) {
      console.error(
        "‚ùå [OFFLINE] Error cr√≠tico obteniendo actualizaciones pendientes:",
        error
      );

      // ‚úÖ FALLBACK EXTREMO
      try {
        const allUpdates = await IndexedDBService.getAll(this.storeName);
        const pendingUpdates = allUpdates.filter(
          (update) =>
            update.sincronizado === false || update.sincronizado === undefined
        );
        console.log(
          `üì¶ [OFFLINE] Fallback: ${pendingUpdates.length} pendientes encontrados`
        );
        return pendingUpdates;
      } catch (fallbackError) {
        console.error("‚ùå [OFFLINE] Error en fallback extremo:", fallbackError);
        return [];
      }
    }
  }

  // ‚úÖ MARCAR ACTUALIZACI√ìN COMO SINCRONIZADA
  async markAsSynced(updateId, serverData = {}) {
    try {
      const update = await IndexedDBService.get(this.storeName, updateId);
      if (!update) {
        console.warn(`‚ö†Ô∏è [OFFLINE] Actualizaci√≥n no encontrada: ${updateId}`);
        return false;
      }

      const updatedRecord = {
        ...update,
        ...serverData,
        sincronizado: true,
        fecha_sincronizacion: new Date().toISOString(),
        intentos: (update.intentos || 0) + 1,
      };

      const success = await IndexedDBService.put(this.storeName, updatedRecord);

      if (success) {
        console.log(
          `‚úÖ [OFFLINE] Actualizaci√≥n marcada como sincronizada: ${updateId}`
        );
        this.notifyStockPendingUpdate();
        return true;
      }

      return false;
    } catch (error) {
      console.error(`‚ùå [OFFLINE] Error marcando como sincronizada:`, error);
      return false;
    }
  }

  // ‚úÖ NOTIFICAR CAMBIOS EN ACTUALIZACIONES PENDIENTES
  notifyStockPendingUpdate() {
    if (typeof window !== "undefined" && window.dispatchEvent) {
      window.dispatchEvent(new CustomEvent("stockPendingUpdatesChanged"));
    }
  }

  // ‚úÖ OBTENER USUARIO ACTUAL
  getCurrentUserId() {
    try {
      const userData = localStorage.getItem("user");
      if (userData) {
        const user = JSON.parse(userData);
        return user.id || user.uid || "unknown";
      }
      return "unknown";
    } catch (error) {
      return "unknown";
    }
  }

  // En InventoryOfflineController.js - ACTUALIZAR getPendingCount
  async getPendingCount() {
    try {
      const updates = await this.getPendingStockUpdates(); // ‚úÖ Usa el m√©todo corregido
      return updates.length;
    } catch (error) {
      console.error("‚ùå [OFFLINE] Error obteniendo contador:", error);
      return 0;
    }
  }
  // ‚úÖ M√âTODO TEMPORAL DE EMERGENCIA
  async emergencyGetPendingStock() {
    try {
      console.log("üö® [EMERGENCY] Obteniendo stock pendiente de emergencia...");

      const allData = await IndexedDBService.getAll("stock_pendientes");
      console.log(`üìä [EMERGENCY] ${allData.length} registros totales`);

      const pending = allData.filter((item) => {
        // ‚úÖ M√öLTIPLES VERIFICACIONES
        if (item.sincronizado === false) return true;
        if (item.sincronizado === undefined) return true;
        if (item.sincronizado === null) return true;
        if (!item.hasOwnProperty("sincronizado")) return true;
        return false;
      });

      console.log(`üì¶ [EMERGENCY] ${pending.length} pendientes encontrados`);

      // ‚úÖ LOG DEL REGISTRO ESPEC√çFICO
      const specificRecord = allData.find(
        (item) => item.id_local === "stock_1762044568354_35ol875iu"
      );
      if (specificRecord) {
        console.log("üéØ [EMERGENCY] Registro espec√≠fico:", {
          id_local: specificRecord.id_local,
          sincronizado: specificRecord.sincronizado,
          tipo: typeof specificRecord.sincronizado,
        });
      }

      return pending;
    } catch (error) {
      console.error("‚ùå [EMERGENCY] Error cr√≠tico:", error);
      return [];
    }
  }
  // ‚úÖ OBTENER INVENTARIO EN CACHE (PARA MODO OFFLINE)
  async getCachedInventory() {
    try {
      const productos = await IndexedDBService.getAll("productos");
      console.log(`üì¶ [OFFLINE] ${productos.length} productos en cache`);
      return productos;
    } catch (error) {
      console.error("‚ùå [OFFLINE] Error obteniendo inventario cache:", error);
      return [];
    }
  }
}

export default new InventoryOfflineController();
