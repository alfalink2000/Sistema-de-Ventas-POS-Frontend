// actions/productsActions.js - CON SOPORTE OFFLINE COMPLETO
import { types } from "../types/types";
import { fetchConToken } from "../helpers/fetch";
import Swal from "sweetalert2";
import { useOfflineOperations } from "../hooks/useOfflineOperations";

export const loadProducts = (filters = {}) => {
  return async (dispatch) => {
    console.log("üîÑ [PRODUCTS] Iniciando carga de productos...", {
      online: navigator.onLine,
      filters,
    });

    dispatch({ type: types.productsStartLoading });

    try {
      const { getProductsOffline, syncProductsOffline, isCacheUpdated } =
        useOfflineOperations();

      let productos = [];
      let fromCache = false;

      if (navigator.onLine) {
        // ‚úÖ CON CONEXI√ìN: Sincronizar y cargar desde servidor
        console.log("üåê [PRODUCTS] Cargando desde servidor...");

        const response = await fetchConToken("productos");
        console.log("üì¶ [PRODUCTS] Respuesta del backend:", response);

        if (response && response.ok === true) {
          // Determinar estructura de respuesta
          if (response.productos && Array.isArray(response.productos)) {
            productos = response.productos;
          } else if (Array.isArray(response)) {
            productos = response;
          } else if (response.rows && Array.isArray(response.rows)) {
            productos = response.rows;
          }

          console.log(
            `‚úÖ [PRODUCTS] ${productos.length} productos cargados desde servidor`
          );

          // ‚úÖ SINCRONIZAR CON OFFLINE
          const syncResult = await syncProductsOffline();
          if (syncResult.success) {
            console.log(
              `üíæ [PRODUCTS] ${syncResult.count} productos sincronizados offline`
            );
          }
        } else {
          console.warn(
            "‚ö†Ô∏è [PRODUCTS] Respuesta no exitosa desde API, usando cache offline"
          );
          fromCache = true;
          productos = await getProductsOffline(filters);
        }
      } else {
        // ‚úÖ SIN CONEXI√ìN: Cargar desde cache offline
        console.log("üì± [PRODUCTS] Modo offline - cargando desde cache local");
        fromCache = true;
        productos = await getProductsOffline(filters);
      }

      // ‚úÖ APLICAR FILTROS ADICIONALES SI ES NECESARIO
      if (filters.categoria_id && !fromCache) {
        productos = productos.filter(
          (p) => p.categoria_id === filters.categoria_id
        );
      }

      if (filters.activo !== undefined && !fromCache) {
        productos = productos.filter((p) => p.activo === filters.activo);
      }

      // ‚úÖ ENRIQUECER DATOS PARA EL FRONTEND
      const productosEnriquecidos = productos.map((producto) => ({
        ...producto,
        estado_stock:
          producto.stock <= 0
            ? "agotado"
            : producto.stock <= producto.stock_minimo
            ? "bajo"
            : "normal",
        necesita_reposicion: producto.stock <= producto.stock_minimo,
        ganancia_estimada: producto.precio_venta - producto.precio_compra,
        margen_ganancia:
          producto.precio_compra > 0
            ? (
                ((producto.precio_venta - producto.precio_compra) /
                  producto.precio_compra) *
                100
              ).toFixed(1)
            : 0,
      }));

      console.log(
        `‚úÖ [PRODUCTS] ${productosEnriquecidos.length} productos procesados (${
          fromCache ? "CACHE" : "SERVER"
        })`
      );

      dispatch({
        type: types.productsLoad,
        payload: productosEnriquecidos,
      });

      return productosEnriquecidos;
    } catch (error) {
      console.error("‚ùå [PRODUCTS] Error cargando productos:", error);

      // ‚úÖ FALLBACK: Intentar cargar desde cache offline
      try {
        const { getProductsOffline } = useOfflineOperations();
        const productosOffline = await getProductsOffline(filters);

        console.log(
          `üì± [PRODUCTS] Fallback: ${productosOffline.length} productos desde cache offline`
        );

        dispatch({
          type: types.productsLoad,
          payload: productosOffline,
        });

        return productosOffline;
      } catch (offlineError) {
        console.error(
          "‚ùå [PRODUCTS] Error incluso en modo offline:",
          offlineError
        );

        dispatch({
          type: types.productsLoad,
          payload: [],
        });

        return [];
      }
    } finally {
      dispatch({ type: types.productsFinishLoading });
    }
  };
};

// ‚úÖ BUSCAR PRODUCTOS CON SOPORTE OFFLINE
export const searchProducts = (searchTerm, categoriaId = null) => {
  return async (dispatch) => {
    try {
      console.log(`üîç [PRODUCTS] Buscando: "${searchTerm}"`, {
        categoriaId,
        online: navigator.onLine,
      });

      const { searchProductsOffline } = useOfflineOperations();

      let resultados = await searchProductsOffline(searchTerm, categoriaId);

      // ‚úÖ ENRIQUECER RESULTADOS
      resultados = resultados.map((producto) => ({
        ...producto,
        estado_stock:
          producto.stock <= 0
            ? "agotado"
            : producto.stock <= producto.stock_minimo
            ? "bajo"
            : "normal",
        coincide_nombre: producto.nombre
          .toLowerCase()
          .includes(searchTerm.toLowerCase()),
        coincide_codigo: producto.codigo_barras?.includes(searchTerm),
      }));

      console.log(
        `‚úÖ [PRODUCTS] ${resultados.length} productos encontrados para: "${searchTerm}"`
      );

      dispatch({
        type: types.productsSearch,
        payload: resultados,
      });

      return resultados;
    } catch (error) {
      console.error("‚ùå [PRODUCTS] Error buscando productos:", error);

      dispatch({
        type: types.productsSearch,
        payload: [],
      });

      return [];
    }
  };
};

// ‚úÖ OBTENER PRODUCTO POR ID CON SOPORTE OFFLINE
export const getProductById = (productId) => {
  return async (dispatch) => {
    try {
      console.log(`üîÑ [PRODUCTS] Obteniendo producto: ${productId}`);

      const { getProductByIdOffline } = useOfflineOperations();

      const producto = await getProductByIdOffline(productId);

      if (!producto) {
        console.warn(`‚ö†Ô∏è [PRODUCTS] Producto ${productId} no encontrado`);
        return null;
      }

      // ‚úÖ ENRIQUECER DATOS
      const productoEnriquecido = {
        ...producto,
        estado_stock:
          producto.stock <= 0
            ? "agotado"
            : producto.stock <= producto.stock_minimo
            ? "bajo"
            : "normal",
        ganancia_estimada: producto.precio_venta - producto.precio_compra,
        margen_ganancia:
          producto.precio_compra > 0
            ? (
                ((producto.precio_venta - producto.precio_compra) /
                  producto.precio_compra) *
                100
              ).toFixed(1)
            : 0,
        necesita_reposicion: producto.stock <= producto.stock_minimo,
      };

      console.log(
        `‚úÖ [PRODUCTS] Producto cargado: ${productoEnriquecido.nombre}`
      );

      dispatch({
        type: types.productSetActive,
        payload: productoEnriquecido,
      });

      return productoEnriquecido;
    } catch (error) {
      console.error(
        `‚ùå [PRODUCTS] Error obteniendo producto ${productId}:`,
        error
      );
      return null;
    }
  };
};

// ‚úÖ ACTUALIZAR STOCK CON SOPORTE OFFLINE
export const updateProductStock = (productoId, stockData) => {
  return async (dispatch) => {
    try {
      console.log(`üîÑ [PRODUCTS] Actualizando stock: ${productoId}`, stockData);

      const { updateStockOffline } = useOfflineOperations();

      const resultado = await updateStockOffline(
        productoId,
        stockData.nuevo_stock,
        {
          tipo: "ajuste_manual",
          motivo: stockData.motivo || "Ajuste manual",
          usuario: stockData.usuario || "Sistema",
        }
      );

      if (resultado.success) {
        console.log(
          `‚úÖ [PRODUCTS] Stock actualizado: ${productoId} -> ${stockData.nuevo_stock}`
        );

        // ‚úÖ ACTUALIZAR ESTADO GLOBAL
        dispatch({
          type: types.productUpdateStock,
          payload: {
            productoId,
            stock_anterior: resultado.stock_anterior,
            stock_nuevo: resultado.stock_nuevo,
            producto: resultado.producto,
          },
        });

        await Swal.fire({
          icon: "success",
          title: "Stock Actualizado",
          text: `Stock actualizado correctamente: ${resultado.stock_anterior} ‚Üí ${resultado.stock_nuevo}`,
          timer: 2000,
          showConfirmButton: false,
        });

        return true;
      } else {
        throw new Error(resultado.error);
      }
    } catch (error) {
      console.error(
        `‚ùå [PRODUCTS] Error actualizando stock ${productoId}:`,
        error
      );

      await Swal.fire({
        icon: "error",
        title: "Error",
        text: error.message || "Error al actualizar stock",
        confirmButtonText: "Entendido",
      });

      return false;
    }
  };
};

// ‚úÖ REDUCIR STOCK POR VENTA CON SOPORTE OFFLINE
export const reduceProductStock = (productoId, cantidad, ventaId = null) => {
  return async (dispatch) => {
    try {
      console.log(`üîÑ [PRODUCTS] Reduciendo stock: ${productoId} -${cantidad}`);

      const { reduceStockOffline } = useOfflineOperations();

      const resultado = await reduceStockOffline(productoId, cantidad, ventaId);

      if (resultado.success) {
        console.log(`‚úÖ [PRODUCTS] Stock reducido: ${productoId} -${cantidad}`);

        dispatch({
          type: types.productUpdateStock,
          payload: {
            productoId,
            stock_anterior: resultado.stock_anterior,
            stock_nuevo: resultado.stock_nuevo,
            producto: resultado.producto,
          },
        });

        return true;
      } else {
        console.error(
          `‚ùå [PRODUCTS] Error reduciendo stock: ${resultado.error}`
        );
        return false;
      }
    } catch (error) {
      console.error(
        `‚ùå [PRODUCTS] Error reduciendo stock ${productoId}:`,
        error
      );
      return false;
    }
  };
};

// ‚úÖ CARGAR PRODUCTOS BAJO STOCK CON SOPORTE OFFLINE
export const loadLowStockProducts = (limite = 10) => {
  return async (dispatch) => {
    try {
      console.log(`üîÑ [PRODUCTS] Cargando productos bajo stock...`);

      const { getLowStockProductsOffline } = useOfflineOperations();

      const productosBajoStock = await getLowStockProductsOffline(limite);

      console.log(
        `üìâ [PRODUCTS] ${productosBajoStock.length} productos con stock bajo`
      );

      dispatch({
        type: types.productsLoadLowStock,
        payload: productosBajoStock,
      });

      return productosBajoStock;
    } catch (error) {
      console.error(
        "‚ùå [PRODUCTS] Error cargando productos bajo stock:",
        error
      );

      dispatch({
        type: types.productsLoadLowStock,
        payload: [],
      });

      return [];
    }
  };
};

// ‚úÖ SINCRONIZAR PRODUCTOS MANUALMENTE
export const syncProducts = () => {
  return async (dispatch) => {
    try {
      if (!navigator.onLine) {
        await Swal.fire({
          icon: "warning",
          title: "Sin conexi√≥n",
          text: "No hay conexi√≥n a internet para sincronizar",
          confirmButtonText: "Entendido",
        });
        return false;
      }

      await Swal.fire({
        title: "Sincronizando...",
        text: "Actualizando cat√°logo de productos",
        allowOutsideClick: false,
        didOpen: () => {
          Swal.showLoading();
        },
      });

      const { syncProductsOffline } = useOfflineOperations();
      const resultado = await syncProductsOffline();

      Swal.close();

      if (resultado.success) {
        // Recargar productos despu√©s de sincronizar
        await dispatch(loadProducts());

        await Swal.fire({
          icon: "success",
          title: "Sincronizaci√≥n completada",
          text:
            resultado.message || `${resultado.count} productos actualizados`,
          timer: 2000,
          showConfirmButton: false,
        });

        return true;
      } else {
        throw new Error(resultado.error);
      }
    } catch (error) {
      console.error("‚ùå [PRODUCTS] Error sincronizando productos:", error);

      Swal.close();

      await Swal.fire({
        icon: "error",
        title: "Error de sincronizaci√≥n",
        text: error.message || "No se pudieron actualizar los productos",
        confirmButtonText: "Entendido",
      });

      return false;
    }
  };
};

// ‚úÖ OBTENER ESTAD√çSTICAS DE PRODUCTOS
export const loadProductsStats = () => {
  return async (dispatch) => {
    try {
      const { getProductsOffline } = useOfflineOperations();

      const productos = await getProductsOffline();

      const stats = {
        total: productos.length,
        activos: productos.filter((p) => p.activo).length,
        inactivos: productos.filter((p) => !p.activo).length,
        agotados: productos.filter((p) => p.stock === 0).length,
        bajo_stock: productos.filter(
          (p) => p.stock > 0 && p.stock <= p.stock_minimo
        ).length,
        valor_total_inventario: productos.reduce(
          (sum, p) => sum + p.stock * p.precio_compra,
          0
        ),
        productos_por_categoria: {},
      };

      // Agrupar por categor√≠a
      productos.forEach((producto) => {
        if (!stats.productos_por_categoria[producto.categoria_id]) {
          stats.productos_por_categoria[producto.categoria_id] = 0;
        }
        stats.productos_por_categoria[producto.categoria_id]++;
      });

      dispatch({
        type: types.productsLoadStats,
        payload: stats,
      });

      return stats;
    } catch (error) {
      console.error("‚ùå [PRODUCTS] Error cargando estad√≠sticas:", error);
      return {};
    }
  };
};

export const setActiveProduct = (product) => ({
  type: types.productSetActive,
  payload: product,
});

export const clearActiveProduct = () => ({
  type: types.productClearActive,
});
